import os
import tarfile
import zipfile

from domains.database import AutoSave


def zip_method(name: str = "students.dat"):
    base_dir = os.getcwd()
    real_base = os.path.realpath(base_dir)

    with zipfile.ZipFile(
        name, "w", compression=zipfile.ZIP_DEFLATED, compresslevel=9
    ) as zipf:
        for path in AutoSave.list_paths():
            full_path = (
                os.path.join(base_dir, path) if not os.path.isabs(path) else path
            )

            if not os.path.isfile(full_path):
                continue

            real_file = os.path.realpath(full_path)

            if not real_file.startswith(real_base):
                continue

            arcname = os.path.relpath(real_file, real_base)
            zipf.write(real_file, arcname)


@staticmethod
def tar_gz_method(name: str = "students.dat"):
    base_dir = os.getcwd()
    real_base = os.path.realpath(base_dir)

    with tarfile.open(name, "w:gz", compresslevel=9) as tar:
        for path in AutoSave.list_paths():
            full_path = (
                os.path.join(base_dir, path) if not os.path.isabs(path) else path
            )

            if not os.path.isfile(full_path):
                continue

            real_file = os.path.realpath(full_path)

            if not real_file.startswith(real_base):
                continue

            arcname = os.path.relpath(real_file, real_base)
            tar.add(real_file, arcname=arcname)

import os
import tarfile
import zipfile


def extract_all(filename, output_dir=None):
    if output_dir is None:
        output_dir = os.getcwd()

    os.makedirs(output_dir, exist_ok=True)

    if zipfile.is_zipfile(filename):
        with zipfile.ZipFile(filename, "r") as zipf:
            zipf.extractall(output_dir)
    elif tarfile.is_tarfile(filename):
        with tarfile.open(filename, "r:*") as tar:
            tar.extractall(output_dir)
    else:
        raise ValueError(f"Unknown compressed file format: {filename}")

import json
import math
import os
from dataclasses import asdict
from datetime import datetime
from functools import wraps
from typing import Dict

from domains.course import Courses
from domains.database import AutoSave, StudentMarksDatabase
from domains.student import StudentMarks


class Helper:
    @staticmethod
    def auto_save(file: str):
        AutoSave.files.append(os.path.abspath(file))
        with open(AutoSave.files[0], "w", encoding="utf-8") as f:
            for file in AutoSave.files:
                f.write(f"{file}\n")

        def decorator(func):
            @wraps(func)
            def wrapper(self, *args, **kwargs):
                result = func(self, *args, **kwargs)

                with open(file, "w", encoding="utf-8") as f:
                    json.dump(result, f, indent=4, ensure_ascii=False, default=str)

                return result

            return wrapper

        return decorator


class StudentMarksInput(StudentMarksDatabase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def _input_student_info_helper(self, student: StudentMarks):
        student.id = input("ID: ")
        student.name = input("Name: ")
        student.DoB = datetime.strptime(input("DoB (DD-MM-YYYY): "), "%d-%m-%Y")

    def _input_course_info_helper(self, courses: Courses):
        courses.id = input("Course ID: ")
        courses.name = input("Course Name: ")
        courses.credits = int(input("Credits: "))

    @Helper.auto_save("students.txt")
    def _input_student_info(self) -> Dict:
        student_number: int = int(input("\nEnter number of students: "))
        for _ in range(student_number):
            print()
            student = StudentMarks()
            self._input_student_info_helper(student)
            self._students[student.id] = student

        return {
            sid: {
                **{k: v for k, v in asdict(student).items() if k != "marks"},
                "DoB": student.DoB.isoformat(),
            }
            for sid, student in self._students.items()
        }

    @Helper.auto_save("courses.txt")
    def _input_course_info(self) -> Dict:
        course_number: int = int(input("\nEnter number of courses: "))
        for _ in range(course_number):
            print()
            course = Courses()
            self._input_course_info_helper(courses=course)
            self._courses[course.id] = course

        return {k: asdict(v) for k, v in self._courses.items()}

    @Helper.auto_save("marks.txt")
    def _input_marks(self) -> Dict[str, Dict[str, float]]:
        while True:
            print("\nAvailable courses:")
            for course in self._courses.values():
                print(f"{course.id}: {course.name}")

            course_id: str = input(
                "Select a course ID to input marks (Enter to cancel): "
            )

            if course_id.strip() == "":
                print("Cancel mark input.")
                break

            if course_id not in self._courses:
                raise ValueError("Invalid course ID!")

            print(f"\nInput marks for course: {self._courses[course_id].name}")
            for student in self._students.values():
                mark = (
                    math.floor(float(input(f"Enter mark for {student.name}: ")) * 10)
                    / 10
                )
                student.marks[course_id] = mark

        return {sid: student.marks for sid, student in self._students.items()}

    def _input_interface(self):
        self._input_student_info()
        self._input_course_info()
        self._input_marks()

import os
import sys

import compress
import decompress
from domains.database import AutoSave, StudentMarksDatabase
from input import StudentMarksInput
from output import StudentMarksOutput


class UI(StudentMarksInput, StudentMarksOutput, StudentMarksDatabase):
    def __init__(self):
        super().__init__()
        self.__before_open()

    def __input(self):
        self._input_interface()

    def __before_open(self):
        if os.path.exists("students.dat"):
            decompress.extract_all("students.dat")
        else:
            return

        for path in AutoSave.list_paths():
            if not os.path.exists(path):
                continue

            fname = os.path.basename(path).lower()
            match fname:
                case "students.txt":
                    self.load_students(path)
                case "courses.txt":
                    self.load_courses(path)
                case "marks.txt":
                    self.load_marks(path)
                case _:
                    pass

    def __list(self, option: str | None = None):
        match option:
            case "courses":
                self._list_courses()
            case "students":
                self._list_students()
            case "marks":
                self._show_course_student_mark(input("Course ID: "))
            case "gpa":
                self._list_students_by_gpa()
            case _:
                print(ValueError("Unknown option"))

    def __check_value(self):
        if not self._students or not self._courses:
            raise ValueError("Please input first")

    def __compress_menu(self):
        method: str = input("Compress method (zip, tar.gz): ").strip().lower()

        match method:
            case "zip":
                compress.zip_method()
            case "tar.gz":
                compress.tar_gz_method()
            case _:
                print("Unknown compress method")

    def __before_close(self):
        if (input("Save changes? (Y/n) ").strip().lower() or "y") == "y":
            self.__compress_menu()
        sys.exit(0)

    def main(self):
        while True:
            option: str = (
                input("Work with (input, courses, students, marks, gpa, save, exit): ")
                .strip()
                .lower()
            )

            match option:
                case "input":
                    self.__input()
                case "save":
                    self.__compress_menu()
                case "exit":
                    self.__before_close()
                case _:
                    self.__check_value()
                    self.__list(option=option)


if __name__ == "__main__":
    UI().main()

from domains.database import StudentMarksDatabase


class StudentMarksOutput(StudentMarksDatabase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def _list_courses(self):
        for course in self._courses.values():
            print(course.id, course.name, sep=" - ")

    def _list_students(self):
        for student in self._students.values():
            print(
                f"Name: {student.name}",
                f"ID: {student.id}",
                f"DoB: {student.DoB}",
                sep="\n",
            )

    def _show_course_student_mark(self, course_id: str):
        for student in self._students.values():
            student_mark: float | None = student.marks.get(course_id)

            if student_mark is None:
                raise ValueError("Course ID not found.")

            print(student.name, student_mark, sep=": ")

    def _list_students_by_gpa(self):
        students_with_gpa = [
            (student, self.calculate_gpa(student))
            for student in self._students.values()
        ]

        students_with_gpa.sort(key=lambda x: x[1], reverse=True)

        for student, gpa in students_with_gpa:
            print(f"{student.name} - GPA: {gpa:.2f}")


#
